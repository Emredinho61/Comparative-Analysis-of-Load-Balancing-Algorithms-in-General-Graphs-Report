\chapter{Simulations}\label{chap:simulations}
Simulations are conducted using the PeerSim simulation tool for Java. Different topologies are implemented. For every simulation a output file is generated containing, the loads, sums and weights of every node per round and the mean squared error of the graph per round. Also the configuration files contain information regarding the setting of the simulation, like the network size or the topology chosen for the simulation. These output files are processed using python as a programming language. For plotting purposes \textit{Matplotlib} is chosen, as it provides a variety of options for plotting and a comprehensive and detailed documentation.

\section{PeerSim}
PeerSim is a simulation tool developed for the Java programming language. PeerSim is composed of two engines. The event-based engine and the cycle-based engine. We chose the latter one for our simulations. What makes PeerSim so attractive for simulations of peer-to-peer networks is its high scalability and the ability to program with pluggable components, since there are many components implementing the same interface. In general a simulation utilizing PeerSim is subdivided into four steps. A configuration file is required to create the wished simulation. First, one has to choose a network size for the simulation. Secondly, chosing the protocol one wants to conduct the simulations for. This could be several protocols or only one. After the protocol is chosen, control objects can be initialized to monitor simulation parameters. Our control objects are classes named \textit{<Protocol>Observer}. Lastly, the configuration file has to be invoke the peersim.Simulator class \cite{peersimdocs}. 

PeerSim provides many classes and interfaces, which are useful and needed for the simulation. As suggested earlier, we are chosing a cycle-driven approach rather than the event-driven approach. For this a interface \textit{CDProtocol} is provided by the simulation framework. With this interface comes a method \textit{nextCycle}, which is executed in the beginning of every round. Then there is the \textit{Node} interface. A node as implemented in PeerSim is simply a container that holds protocols. Every node is assigned an ID. The \textit{Linkable} interface provides us with access to the neighboring protocols. If a class implements the \textit{Linkable} interface, one is able to implement some useful methods, namely \textit{getNeighbor}, which picks the neighbor with a specifiable id of the network. The \textit{degree} method, returning the number of neighbors one node has. A method \textit{addNeighbor}, which is supposed to add a neighbor to a nodes neighbors set. This comes in handy, when one needs to implement different topologies to test their algorithms in. And a few more methods. To monitor the simulations control objects are needed. A class implementing the \textit{Control} interface comes with a method \textit{execute}. The \textit{execute} method can be used to monitor or to modify the simulation \cite{peersimdocs}.

\section{Implementation Details}
Both implementations of the algorithms contain of at least two different java classes. Namely, a observer class and a protocol class. Another class that is not protocol specific, but rather is used by both protocols to share protocols is a parameter class named \textit{loadBalancingParameters.java}. It holds the parameters that are used for the simulation, e.g. the round number or the width and the height for the torus grid graph. All protocol specific parameters are handled in the protocol class. The observer class of a algorithm handles the implementation and the monitoring of the protocols. The implementation of the topologies is also handled in the observer classes. Topologies are implemented utilizing the \textit{addNeighbor} method of the protocol class. To generate a link between two nodes, we simply add the node id to the nodes set of neighbors. Since we are in a static setting, the links are created in round 0, which is utilized for initializing purposes. The output files are generated on-the-fly, while simulating. At the end of each round the mean squared error values are appended to the output file.

\todo{Maybe give an implementation example of a topology}